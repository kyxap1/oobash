###############################################
# oobash -- my stillborn, but funny child :-) #
###############################################

oobash is only a fun project and no, there are no real objects, but who cares... ;-)
There is no downward compatibility until version 1.0.

Fast start
===========

To start simply source oobash-<version>.source file:
1) source oobash-<version>.source

To finally clean up your environment again:
1) __cleanUp

How it works
=============

A) command_not_found_handle
############################
Every object.method command is not existing. THe last step before the bash gives you a "command not found" is to see,
if there is a command_not_found_handle function.
This function is part of this framework and is used to handle the object.method situation:
 a) split object.method to object and method
 b) check if object exists
 c) check if method for this object exists
 d) if all checks are fine call the function $method 
    with the arguments object class and the other arguments if there are some:
    __$method "$this" "$class" "$@"
All this action makes the framework a relative slow thing, but everything has its price...
Because the shell executes the command_not_found_handle function in a separate execution environment, no "setters" are available.
You could echo some setter functionality into the environment, but at the moment, this does not happen to avoid environemnt pollution.

B) Registry
###########
Every variable, function, array, alias and class is registered in an associative array with the name __Registry__.
With the pulic __cleanUp function this __Registry__ is used to clean the environment.
Use the __cleanUp function after using the oobash.

C) Objectpool and Attributepool
###############################
After using a constructor, let's see what happened:
String a abc

There are two associative arrays :
* __OBJECTPOOL__
------------------
echo ${!__OBJECTPOOL__[@]}
a (key is a, this is the object name)

echo ${__OBJECTPOOL__[@]}
String@1322347553143967167 (value is class@timestamp)

* __ATTRIBUTEPOOL__
---------------------
echo ${!__ATTRIBUTEPOOL__[@]}
1322347553143967167@string (key is timestamp@attribute)

echo ${__ATTRIBUTEPOOL__[@]}
abc (value of attribute)

If there are more than one attributes describing the "object", then following code is used for the toString "method":
echo "${!__ATTRIBUTEPOOL__[@]}"  | tr " " "\n" | sort | tr "\n" " "

D) Conventions
##############

* Boolean return values:
-------------------------
All public "methods" call a Boolean.TRUE or Boolean.FALSE to represent true or false --> true ore false is echoed to the output channel.
If there is no failure calling the "method" the return value will be 0, independent of any boolean true/false return value.

Only private functions make use of a 0/1 return value to represent a false or true.

E) Create own classes
#####################

if you want to make your own class file
then:
1) use the Class.generator tool

if your file always should be sourced at oobash sourcetime:
1) Put the oobash file, that you generated by the Clas.generator tool
to oobash/src/myClassFiles/
2) Put the array definition in your new file to the other array definitions in the 
oobash-<version>.source file
3) use the import function in the oobash-<version>.source file:
# import myClassFile classes
__import oobash.myClassFiles.<nameOfYourFileWithoutOobashPostfix>

F) Methods declaration
######################

All methods begin with two underscore characters (you can see this in the section command_not_found_handle).
Even if your method doesn't use any argument, the command_not_found_handle function will add two arguments:
1) objectname
2) class name

Method concatenation like a.toLoweCase.toUpperCase is not possible, but you certainly can simulate this by generating new "objects" e.g.
String a abc
String a $(a.toLowerCase)
String a $(a.toUpperCase)

Only the constructors do not follow this main principle (looks to ugly ;-) ).
 
G) "Inheritance" 
################
Inheritance is done by array nesting.
Every class has a __$ClassMethods__ array. The elements of this array are the methods that are defined in this $Class file.
The __XYZMethods__ array are only used for inheritance action.
Every (not abstract) class has another array named: __$Class__. The elements of this array are the elements of one or more __XYZMethods__ arrays.
e.g.
declare -a __Boolean__=(${__BooleanMethods__[@]} ${__ObjectMethods__[@]} ${__ComparableMethods__[@]})
 
H) Autocompletion
#################

 * for our object.method commands
   -------------------------------
   To use autocompletion aliases are generated in the BASH_ALIASES array: 
   BASH_ALIASES["${this}"."${method}"]=""${this}"."${method}""
   The alias does NOT avoid the "command_not_found" situation,
   it is only existing to be able to enjoy autocompletion.

 * for the help system
   --------------------
   $Class stands for any class name that is used in this framework.
   Following line / or similar is there for every $Class.help function.
   complete -W  "$(echo ${__$Class__[@]}) all $Class" $Class.help
   This way an argument wordlist for the $Class.help function is generated and used by the bash autocompletion.  
   The content of the wordlist is every method that can be used by a $Class "object" plus the consructor of the $Class class and the keyword 'all'.

I) I8N
######
The i18n of the bash uses the GNU gettext package.

if you want to make your own oobash.po, oobash.mo file for i18n,
then: 
1) create a directory for your locale under oobash/locale
2) copy oobash/locale/de/* to oobash/locale/<yourLocaleDir>
3) edit the oobash/locale/<yourLocaleDir>oobash.po
4) create your mo file: msgfmt -o oobash.mo oobash.po

Iy you have some text output that should be translated, there are two functions available:
I18n.out.message
I18n.err.message
