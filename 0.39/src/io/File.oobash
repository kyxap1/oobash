##################################################################
# Author:  andreas.gregor.frank@googlemail.com                                
#     
# License: The MIT License
#
# Copyright (c) <2010> <andreas.gregor.frank@googlemail.com>

#################
#################
##             ##
##     FILE    ## 
##             ##
#################
#################


#########################
#                       #
#      CONSTRUCTOR      # 
#                       #
#########################

File() {
   if (( $# == 2 ))
   then
      local this="$1"

      if ! __visible "$this"
      then
         I18n.err.message "Sorry, objectname '\$this' is not valid"
         return 1
      fi  

      if ! __checkForKeywords "$this"
      then
         I18n.err.message "Sorry, objectname '\$this' is a keyword"
         return 1
      fi 

      if ! __periodCheck "$this"
      then
         I18n.err.message "Sorry, no full stop character allowed in objectname"
         return 1
      fi

      local pointer
      if ! pointer=$(System.currentTimeNanos)
      then
         I18n.err.message "Sorry, could not create object '\$this'"
         return 1
      fi

      local pathname="$2"
      local class=$FUNCNAME

      __destructor "$this"

      __alias "$this" $FUNCNAME

      __attribute pathname "$pathname"        

      return 0      
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   local printStream=err
   ${FUNCNAME}.help $FUNCNAME
   return 1	
}
__registerClass File

#####################
#                   #
#      METHODS      # 
#                   #
#####################

__canRead() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -r "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__canWrite() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -w "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__canExecute() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -x "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__getName() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      System.out.println "${file##*/}"
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isDirectory() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -d "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__exists() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -e "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isFile() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -f "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isHidden() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      file=${file##*/}
      if [[ "${file:0:1}" == "." ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__mkdir() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if command -v mkdir >/dev/null 2>&1
      then 
         mkdir -- "$file" >/dev/null 2>&1
         declare -i result=$?
         if (( $result == 0 ))
         then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
         return $result 
      else
         __throw "NotInPathException" ": mkdir not in path"
         return 1
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__mkdirs() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if command -v mkdir >/dev/null 2>&1
      then 
         mkdir -p -- "$file" >/dev/null 2>&1
         declare -i result=$?
         if (( $result == 0 ))
         then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
         return $result
      else
         __throw "NotInPathException" ": mkdir not in path"
         return 1
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__getParent() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if command -v dirname >/dev/null 2>&1
      then 
         dirname -- "$file"
         return $?
      else
         __throw "NotInPathException" ": dirname not in path"
         return 1
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isSymbolicLink() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -L "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isNamedPipe() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -p "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__hasStickyBit() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -k "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isSocket() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -S "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isCharacterSpecial() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -c "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isBlockSpecial() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ -b "$file" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__renameTo() {
   if (( $# == 3 ))
   then
      local this="$1"
      local argobject="$3"
      local argclass
      argclass="$("$argobject".getClass 2>/dev/null)"
      if (( $? == 0 ))
      then
         if [[ "$("$this".getClass)" == "$argclass" ]]
         then
            local str="$("$argobject".toString)" 
            if [[ $("$this".exists) == $(Boolean.TRUE) ]]
            then
               if command -v mv >/dev/null 2>&1
               then
                  mv -- "$("$this".toString)" "$("$argobject".toString)" 2>/dev/null
                  declare -i result=$?
                  if (( $result == 0 ))
                  then
                     Boolean.TRUE
                     return $result
                  fi
               else
                  __throw "NotInPathException" ": mv not in path"
                  return 1   
               fi            
            else
               Boolean.FALSE
               return 0
            fi
         else
            __throw "WrongClassException" " argument $argobject: $("$argobject".getClass)"
            return 1   
         fi
      else
         __throw "IllegalArgumentException" ": Wrong argument: $3"
         return 1
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__setReadable() {   
   case $# in
      3) local readable=$(Boolean.parseBoolean "$3")
         local ownerOnly=$(Boolean.TRUE)
         ;;
      4) local readable=$(Boolean.parseBoolean "$3")
         local ownerOnly=$(Boolean.parseBoolean "$4")
         ;;
      *) __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
         local class="$2"
         local printStream=err
         ${class}.help ${FUNCNAME:2}
         return 1;;
   esac
   if command -v chmod >/dev/null 2>&1
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ "$readable" == $(Boolean.TRUE) ]]
      then
         local setOrDenyPermission="+"
      else
         local setOrDenyPermission="-"   
      fi
      if [[ "$ownerOnly" == $(Boolean.TRUE) ]]
      then
         # owner
         local ownerOrAll="u"
      else
         # all
         local ownerOrAll="a"
      fi
      chmod ${ownerOrAll}${setOrDenyPermission}r -- "$file" 2>/dev/null
      if (( $? == 0 ))
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   else
      __throw "NotInPathException" ": chmod not in path (install the GNU coreutils ?)"
      return 1  
   fi 
}

__setWritable() {
   case $# in
      3) local writable=$(Boolean.parseBoolean "$3")
         local ownerOnly=$(Boolean.TRUE)
         ;;
      4) local writable=$(Boolean.parseBoolean "$3")
         local ownerOnly=$(Boolean.parseBoolean "$4")
         ;;
      *) __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
         local class="$2"
         local printStream=err
         ${class}.help ${FUNCNAME:2}
         return 1;;
   esac
   if command -v chmod >/dev/null 2>&1
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ "$writable" == $(Boolean.TRUE) ]]
      then
         local setOrDenyPermission="+"
      else
         local setOrDenyPermission="-"   
      fi
      if [[ "$ownerOnly" == $(Boolean.TRUE) ]]
      then
         # owner
         local ownerOrAll="u"
      else
         # all
         local ownerOrAll="a"
      fi
      chmod ${ownerOrAll}${setOrDenyPermission}w -- "$file" 2>/dev/null
      if (( $? == 0 ))
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   else
      __throw "NotInPathException" ": chmod not in path (install the GNU coreutils ?)"
      return 1  
   fi 
}

__setExecutable() {
   case $# in
      3) local executable=$(Boolean.parseBoolean "$3")
         local ownerOnly=$(Boolean.TRUE)
         ;;
      4) local executable=$(Boolean.parseBoolean "$3")
         local ownerOnly=$(Boolean.parseBoolean "$4")
         ;;
      *) __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
         local class="$2"
         local printStream=err
         ${class}.help ${FUNCNAME:2}
         return 1;;
   esac
   if command -v chmod >/dev/null 2>&1
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ "$executable" == $(Boolean.TRUE) ]]
      then
         local setOrDenyPermission="+"
      else
         local setOrDenyPermission="-"   
      fi
      if [[ "$ownerOnly" == $(Boolean.TRUE) ]]
      then
         # owner
         local ownerOrAll="u"
      else
         # all
         local ownerOrAll="a"
      fi
      chmod ${ownerOrAll}${setOrDenyPermission}x -- "$file" 2>/dev/null
      if (( $? == 0 ))
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   else
      __throw "NotInPathException" ": chmod not in path (install the GNU coreutils ?)"
      return 1  
   fi      
}

__getCanonicalPath() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".getAbsolutePath)"
      if command -v readlink >/dev/null 2>&1
      then 
         local result=''
         result=$(readlink -e -- "$file")
         if (( $? == 0 ))
         then
            System.out.println "$result"
         else
            if command -v basename >/dev/null 2>&1
            then
               if command -v dirname >/dev/null 2>&1
               then
                  if command -v pwd >/dev/null 2>&1
                  then
                     cd -P -- "$(dirname -- "${file}")" &> /dev/null && System.out.println "$(pwd -P)/$(basename -- "${file}")"
                     if (( $? != 0 ))
                     then
                        readlink -m -- "$file"
                     fi
                  else
                     __throw "NotInPathException" ": pwd not in path"
                     return 1
                  fi
               else
                  __throw "NotInPathException" ": dirname not in path (install the GNU sh-utils ?)"
                  return 1
               fi               
            else
               __throw "NotInPathException" ": basename not in path (install the GNU sh-utils ?)"
               return 1
            fi            
         fi
         return 0   
      fi
      __throw "NotInPathException" ": readlink not in path (install the GNU coreutils ?)"
      return 1
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__getAbsolutePath() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ ${file:0:1} == "." ]]
      then
         System.out.println "$(PWD)"/"$file"
      else
         System.out.println "$file"
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__getPath() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      System.out.println "$file" 
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__isAbsolute() {
   if (( $# == 2 ))
   then
      local this="$1"
      local file="$("$this".toString)"
      if [[ ${file:0:1} == "/" ]]
      then
         Boolean.TRUE
      else
         Boolean.FALSE
      fi
      return 0
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__delete() {
   if (( $# == 2 ))
   then
      if command -v rm >/dev/null 2>&1
      then
         if command -v rmdir >/dev/null 2>&1
         then
            local this="$1"
            local file="$("$this".toString)"
            if [[ "$("$this".exists)" == $(Boolean.TRUE) ]]
            then
               rm -f -- "$file" 2>/dev/null || rmdir -- "$file" 2>/dev/null
               if (( $? == 0 ))
               then
                  Boolean.TRUE
               else
                  Boolean.FALSE
               fi
            else
               Boolean.FALSE
            fi
            return 0
         else
            __throw "NotInPathException" ": rmdir not in path"
            return 1         
         fi
      else
         __throw "NotInPathException" ": rm not in path"
         return 1  
      fi      
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__createNewFile() {
   if (( $# == 2 ))
   then
      if command -v touch >/dev/null 2>&1
      then
         local this="$1"
         local file="$("$this".toString)"
         if [[ $("$this".exists) == $(Boolean.FALSE) ]]
         then 
            touch -- "$file" 2>/dev/null
            if (( $? == 0 ))
            then
               Boolean.TRUE
            else
               Boolean.FALSE
            fi
         else
            Boolean.FALSE
         fi
         return 0  
      else
         __throw "NotInPathException" ": touch not in path"
         return 1  
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__lastModified() {
   if (( $# == 2 ))
   then
      if command -v stat >/dev/null 2>&1
      then
         local this="$1"
         local file="$("$this".toString)"
         local result
         result=$(stat -L -c  "+%Y" -- "$file" 2>/dev/null)
         if (( $? == 0 ))
         then
            if [[ ${result:0:1} == "+" ]]
            then
               if (( ${result} != 0 ))
               then
                  System.out.println "${result:1}000"
               else
                  System.out.println "0"
               fi
            else
               if (( ${result} != 0 ))
               then               
                  System.out.println "${result}000"
               else
                  System.out.println "0"
               fi
            fi
         else
            System.out.println "0"
         fi         
         return 0
      else
         __throw "NotInPathException" ": stat not in path (install the GNU coreutils ?)"
         return 1  
      fi    
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

__setLastModified() {
   if (( $# == 3 ))
   then
      if command -v touch >/dev/null 2>&1
      then
         if __gnudateCheck
         then
            local this="$1"
            local file="$("$this".toString)"
            (declare -i milliSeconds=$3) 2>/dev/null ||  (return 1)
            if (( $? != 0 ))
            then
               __throw "IllegalArgumentException" ": Wrong argument: $3"
               return 1         
            fi            
            declare -i milliSeconds="$3"
            if (( $milliSeconds > 1000 )) || (( $milliSeconds < -1000 ))
            then 
               declare -i secondsLength=$(( ${#milliSeconds}- 3 ))
               declare -i epochSeconds=${milliSeconds:0:secondsLength}
            else
               declare -i epochSeconds=0
            fi
            local timestamp=$(date +"%y%m%d%H%M.%S" -d @$epochSeconds)
            touch -m -t ${timestamp} -- ${file} 2>/dev/null
            if (( $? == 0 ))
            then
               Boolean.TRUE
            else
               Boolean.FALSE
            fi
            return 0
         else
            __throw "NotInPathException" " GNU date is not in path"
            return 1  
         fi
      else
         __throw "NotInPathException" ": touch not in path"
         return 1  
      fi    
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1   
}

__setReadOnly() {
   if (( $# == 2 ))
   then
      if command -v chmod >/dev/null 2>&1
      then
         local this="$1"
         local file="$("$this".toString)"
         local result
         result=$(chmod 444 -- "$file" 2>/dev/null)
         if (( $? == 0 ))
         then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
         return 0
      else
         __throw "NotInPathException" ": chmod not in path (install the GNU coreutils ?)"
         return 1  
      fi    
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   local class="$2"
   local printStream=err
   ${class}.help ${FUNCNAME:2}
   return 1
}

# length
# Masterfunction in the String.oobash file

##################
#                #
#     STATICS    # 
#                #
##################

File.createTemporaryFile() {
   if (( $# == 2 )) || (( $# == 3 ))
   then
      if command -v mktemp >/dev/null 2>&1
      then
         if command -v chmod >/dev/null 2>&1
         then
            local tempdir=${TMPDIR:-/tmp};
            local prefix="$1"
            if (( ${#prefix} < 3 ))
            then
               __throw "IllegalArgumentException" ": prefix must be at least three characters long"
               return 1
            fi
            local suffix="$2"
            if (( $# == 3 ))
            then
               local permissions=''
               permissions=$(__posixFilePermissionsConverter "$3")
               if (( $? != 0 ))
               then
                  __throw "IllegalArgumentException" ": argument "$3" is no posixFilePermission"
                  return 1
               fi
            fi
            local temporaryFile
            temporaryFile=$(mktemp --tmpdir="$tempdir" --suffix="$suffix" "$prefix"XXXXXXXXXXXXXXXXXX 2>/dev/null)
            declare -i returnValue=$?
            if (( $returnValue != 0 ))
            then
               __throw "IOException" ": file could not be created"
               return $returnValue
            fi
            if [[ -n $permissions ]]
            then
               chmod $permissions -- $temporaryFile
            fi
            System.out.println $temporaryFile
            return 0
         else
            __throw "NotInPathException" ": chmod not in path (install the GNU coreutils ?)"
            return 1
         fi      
      else
         __throw "NotInPathException" ": mktemp not in path (install the GNU coreutils ?)"
         return 1
      fi
   fi 
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   local printStream=err
   File.help ${FUNCNAME}
   return 1      
}
__registerFunction File.createTemporaryFile

File.createTempFile() {
   if (( $# == 1 )) || (( $# == 2 ))
   then
      local prefix="$1"
      local suffix=${2:-.tmp}
      File.createTemporaryFile "$prefix" "$suffix"
      return 0
   fi 
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   local printStream=err
   File.help ${FUNCNAME}
   return 1
}
__registerFunction File.createTempFile

#################
#               #
#     HELP      # 
#               #
#################

complete -W  "$(echo ${__File__[@]}) all File createTempFile createTemporaryFile" File.help

File.help() {  
   local printStream=${printStream:-out}
   if (( $# == 0 ))
   then
      System.${printStream}.println "
      Usage: File.help all|methodname|constructor
      Available methods:
      -File -isDirectory -exists -toString
      -canRead -canWrite -canExecute
      -getName -hashCode -length
      -isHidden -isFile -mkdir -mkdirs -getParent
      -getClass -equals -renameTo -isSymbolicLink 
      -isNamedPipe -hasStickyBit -isSocket 
      -isCharacterSpecial -isBlockSpecial -compareTo
      -setExecutable -setReadable -setWritable 
      -setReadOnly -File.createTempFile -delete
      -getAbsolutePath -getCanonicalPath -getPath -isAbsolute
      -File.createTemporaryFile -createNewFile -lastModified 
      -setLastModified
      Constructor: 
      -File 
                 "
      return 0
   fi  
   while (($#))
   do
      local match=$(Boolean.FALSE)  
      case $1 in  
         File|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               File
                  Constructor for the File objects.
               Parameters:
                  objectname 
                  filename
                  No \".\" character is allowed in the objectname string.
               Returns
                  None
               Example:
                  File a testfile 
            ";;&
         compareTo|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               compareTo
                  Compares two abstract pathnames lexicographically. 
                  The ordering defined by this method depends upon the underlying system. 
                  Alphabetic case is significant in comparing pathnames.
               Parameters:
                  f - a File object
               Throws:
                  WrongClassException  - if argument has the wrong class  
                  IllegalArgumentException - argument is no object
                                           - if number of arguments != 1
               Returns:
                  Zero if the argument is equal to this abstract pathname, a value less 
                  than zero if this abstract pathname is lexicographically less than the 
                  argument, or a value greater than zero if this abstract pathname is 
                  lexicographically greater than the argument
               Example:
                  File a abcd
                  File b abcd
                  a.compareTo b
                  >>>0
                  File b ab
                  a.compareTo b
                  >>>2
                  File b abcde
                  a.compareTo b
                  >>>-1
                  File b ""
                  a.compareTo b
                  >>>4
                  File b x
                  a.compareTo b
                  >>>-23
                  File b \"ab c\"
                  a.compareTo b
                  >>>67
            ";;&
         exists|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               exists
                  Tests whether the file or directory denoted by this abstract pathname exists. 
               Parameters:
                  None
               Returns:
                  true if and only if the file or directory denoted by this abstract pathname 
                  exists; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX/yyy
                  a.exists
                  >>>false
            ";;&
         equals|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               equals
                  Tests this abstract pathname for equality with the given object. 
                  Returns true if and only if the argument is an 
                  abstract pathname that denotes the same file or directory as this 
                  abstract pathname.
               Parameters:
                  anObject - The object to be compared with
               Returns:
                  true if and only if the objects are the same; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 1
               Example:
                  File a yyy
                  File b yyy
                  File c xxx
                  a.equals c
                  >>>false
                  a.equals b
                  >>>true
            ";;&
         getClass|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getClass
                  Returns the runtime class of this Object.
               Parameters:
                 None
               Returns:
                  The Class object that represents the runtime class of this object.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a xxx
                  a.getClass
                  >>>class File
            ";;& 
         isDirectory|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isDirectory
                  Tests whether the file denoted by this abstract pathname is a directory. 
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname exists and 
                  is a directory; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX/yyy
                  a.isDirectory
                  >>>false
            ";;&
         canRead|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               canRead
                  Tests whether the application can read the file 
                  denoted by this abstract pathname.
               Parameters:
                  None
               Returns:
                  true if and only if the file specified by this abstract pathname exists
                  and can be read by the application; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX/yyy
                  a.canRead
                  >>>false
            ";;&
         canExecute|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               canExecute
                  Tests whether the application can execute the file 
                  denoted by this abstract pathname.
               Parameters:
                  None
               Returns:
                  true if and only if the file specified by this abstract pathname exists
                  and can be executed by the application; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX/yyy
                  a.canExecute
                  >>>false
            ";;&
         canWrite|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               canWrite
                  Tests whether the application can write the file 
                  denoted by this abstract pathname.
               Parameters:
                  None
               Returns:
                  true if and only if the file specified by this abstract pathname exists
                  and can be written by the application; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX/yyy
                  a.canWrite
                  >>>false
               ";;&
         length|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               length
                  Returns the length of the file denoted by this abstract pathname. 
                  The return value is unspecified if this pathname denotes a directory.
               Parameters:
                  None  
               Returns:
                  The length, in bytes, of the file denoted by this abstract pathname. 
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  echo abc > /tmp/abc
                  a.length
                  >>>4
               ";;&
         toString|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               toString
                  Returns the pathname string of this abstract pathname. 
               Parameters:
                  None
               Returns:
                  The string form of this abstract pathname
               Throws:
                  NotInPathException - if sort not in path
                                     - if tr not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.toString
                  >>>/tmp/abc
               ";;&
         hashCode|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               hashCode
                  Computes a hash code for this abstract pathname. Because 
                  equality of abstract pathnames is inherently system-dependent, 
                  so is the computation of their hash codes. On UNIX systems, the 
                  hash code of an abstract pathname is equal to the exclusive or of 
                  the hash code of its pathname string and the decimal value 1234321.
               Parameters:
                  None 
               Returns:
                  A hash code for this abstract pathname
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.hashCode
                  >>>-889608758
            ";;&
         getParent|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getParent
                  Returns the pathname string of this abstract pathname's parent, 
                  or "." if this pathname does not name a parent directory.
                  The parent of an abstract pathname consists of the pathname's prefix, 
                  if any, and each name in the pathname's name sequence except for the last. 
                  If the name sequence is empty then the pathname does not name a parent directory.
               Parameters:
                  None
               Returns:
                  The pathname string of the parent directory named by this abstract pathname, 
                  or "." if this pathname does not name a parent
               Throws:
                  NotInPathException - if dirname is not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File x dfve
                  x.getParent
                  >>>.
                  File x /tmp/ee/ergr
                  x.getParent
                  >>>/tmp/ee
            ";;&
         mkdirs|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               mkdirs
                  Creates the directory named by this abstract pathname, including 
                  any necessary but nonexistent parent directories.
               Parameters:
                  None
               Returns:
                  true if and only if the directory was created, along with all 
                  necessary parent directories; false otherwise
               Throws:
                  NotInPathException - if mkdir is not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/a/b/c
                  a.mkdirs
                  >>>true
            ";;&
         mkdir|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               mkdir
                  Creates the directory named by this abstract pathname.
               Parameters:
                  None
               Returns:
                  true if and only if the directory was created; false otherwise
               Throws:
                  NotInPathException - if mkdir is not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/a/b/c
                  a.mkdir
                  >>>false
                  File a /tmp/a
                  a.mkdir
                  >>>true
            ";;&
         isHidden|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isHidden
                  Tests whether the file named by this abstract pathname is a hidden file. 
                  The exact definition of hidden is system-dependent. On UNIX systems, a file 
                  is considered to be hidden if its name begins with a period character ('.').
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname is hidden 
                  according to the conventions of the underlying platform.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.isHidden
                  >>>false
                  File a /tmp/.abc
                  >>>true
            ";;&
         isFile|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isFile
                  Tests whether the file denoted by this abstract pathname is a normal file. 
                  A file is normal if it is not a directory and, in addition, satisfies other 
                  system-dependent criteria.
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname exists and 
                  is a normal file; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX
                  a.isFile
                  >>>false 
            ";;&
         isSymbolicLink|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isSymbolicLink
                  Tests whether the file denoted by this abstract pathname is a symbolic link. 
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname exists and 
                  is a symbolic link; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX
                  a.isSymbolicLink
                  >>>false 
            ";;&
         isNamedPipe|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isNamedPipe
                  Tests whether the file denoted by this abstract pathname is a named pipe. 
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname exists and 
                  is a named pipe; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX
                  a.isNamedPipe
                  >>>false 
            ";;&
         hasStickyBit|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               hasStickyBit
                  Tests whether the stick bit is set on the file denoted by this abstract pathname. 
               Parameters:
                  None
               Returns:
                  true if and only if the stick bit is set on the file denoted by this abstract pathname; 
                  false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX
                  a.hasStickyBit
                  >>>false 
            ";;&
         isSocket|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isSocket
                  Tests whether the file denoted by this abstract pathname is a socket. 
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname exists and 
                  is a socket; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX
                  a.isSocket
                  >>>false 
            ";;&
         isCharacterSpecial|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isCharacterSpecial
                  Tests whether the file denoted by this abstract pathname is a character 
                  special. 
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname exists and 
                  is a character special; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX
                  a.isCharacterSpecial
                  >>>false 
            ";;&
         isBlockSpecial|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isBlockSpecial
                  Tests whether the file denoted by this abstract pathname is a block special. 
               Parameters:
                  None
               Returns:
                  true if and only if the file denoted by this abstract pathname exists and 
                  is a block special; false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /XXX
                  a.isBlockSpecial
                  >>>false 
            ";;&
         renameTo|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "         
               renameTo
                  Renames the file denoted by this abstract pathname.
                  The rename operation might not be able to move a file from one filesystem to another, 
                  it might not be atomic, and it might not succeed if a file with the destination abstract 
                  pathname already exists. The return value should always be checked to make sure that the
                  rename operation was successful.
               Parameters:
                  File object describing the new abstract pathname for the named file
               Returns:
                  true if and only if the renaming succeeded; false otherwise
               Throws:
                  WrongClassException - if argument has the wrong class 
                  NotInPathException - if mv is not in path
                  IllegalArgumentException - if the argument is no object
                                           - if number of arguments != 1
               Example:
                  File a /tmp/iExist
                  File b /tmp/xxx 
                  a.renameTo b
                  >>>true
            ";;&
         setWritable|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println " 
               setWritable
                  Sets the owner's or everybody's write permission for this abstract pathname.
               Parameters:
                  writable - If true, sets the access permission to allow write operations; 
                  if false to disallow write operations
                  [ownerOnly - If true, the write permission applies only to the owner's write permission; 
                  otherwise, it applies to everybody. If the underlying file system can not distinguish the owner's 
                  write permission from that of others, then the permission will apply to everybody, regardless 
                  of this value.
                  Default: true]
               Returns:
                  true if and only if the operation succeeded. The operation will fail if the user does not have 
                  permission to change the access permissions of this abstract pathname.
               Throws:
                  IllegalArgumentException - if number of arguments != 1 AND !=2
               Example:
                  File a /tmp/iExist
                  a.setWritable true
                  >>>true
                  a.setWritable true false
                  >>>true               
            ";;&
         setReadable|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println " 
               setReadable
                  Sets the owner's or everybody's read permission for this abstract pathname.
               Parameters:
                  readable - If true, sets the access permission to allow read operations; 
                  if false to disallow read operations
                  [ownerOnly - If true, the read permission applies only to the owner's read permission; 
                  otherwise, it applies to everybody. If the underlying file system can not distinguish the owner's 
                  read permission from that of others, then the permission will apply to everybody, regardless of this value.
                  Default: true]               
               Returns:
                  true if and only if the operation succeeded. The operation will fail if the user does not have permission
                  to change the access permissions of this abstract pathname. If readable is false and the underlying file 
                  system does not implement a read permission, then the operation will fail.
               Throws:
                  IllegalArgumentException - if number of arguments != 1 AND !=2
               Example:
                  File a /tmp/iExist
                  a.setReadable true
                  >>>true
                  a.setReadable true false
                  >>>true               
            ";;&
         setExecutable|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println " 
               setExecutable
                  Sets the owner's or everybody's execute permission for this abstract pathname.
               Parameters:
                  executable - If true, sets the access permission to allow execute operations; if false to disallow 
                  execute operations
                  [ownerOnly - If true, the execute permission applies only to the owner's execute permission; 
                  otherwise, it applies to everybody. If the underlying file system can not distinguish the owner's 
                  execute permission from that of others, then the permission will apply to everybody, 
                  regardless of this value.
                  Default: true]                
               Returns:
                  true if and only if the operation succeeded. The operation will fail if the user does not have 
                  permission to change the access permissions of this abstract pathname. If executable is false 
                  and the underlying file system does not implement an execute permission, then the operation will fail.
               Throws:
                  IllegalArgumentException - if number of arguments != 1 AND !=2
               Example:
                  File a /tmp/iExist
                  a.setExecutable true
                  >>>true
                  a.setExecutable true false
                  >>>true               
            ";;&
         getCanonicalPath|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "         
               getCanonicalPath
                  Returns the canonical pathname string of this abstract pathname.

                  A canonical pathname is both absolute and unique. This method first converts this pathname to absolute 
                  form if necessary, as if by invoking the getAbsolutePath() method, and then maps it to its unique form 
                  in a system-dependent way. This typically involves removing redundant names such as "." and ".." from 
                  the pathname, resolving symbolic links on UNIX platforms.

                  Every pathname that denotes an existing file or directory has a unique canonical form. Every pathname 
                  that denotes a nonexistent file or directory also has a unique canonical form. The canonical form of 
                  the pathname of a nonexistent file or directory may be different from the canonical form of the same 
                  pathname after the file or directory is created. Similarly, the canonical form of the pathname of an 
                  existing file or directory may be different from the canonical form of the same pathname after the file 
                  or directory is deleted.
               Parameters:
                  None
               Returns:
                  The canonical pathname string denoting the same file or directory as this abstract pathname
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /xxx/s
                  a.getCanonicalPath
                  >>>/xxx/s              
            ";;&        
         setReadOnly|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println " 
               setReadOnly
                  Marks the file or directory named by this abstract pathname so that only read operations are allowed. 
               Parameters:
                  None
               Returns:
                  true if and only if the operation succeeded; false otherwise
               Throws:
                  NotInPathException - if chmod is not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/iExist
                  a.setReadOnly
                  >>>true           
            ";;&      
         lastModified|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "         
               lastModified
                  Returns the time that the file denoted by this abstract pathname was last modified.
               Parameters:
                  None
               Returns:
                  A long value representing the time the file was last modified, measured in milliseconds 
                  since the epoch (00:00:00 GMT, January 1, 1970), or 0L if the file does not exist or if 
                  an I/O error occurs
               Throws:
                  NotInPathException - if stat is not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.lastModified
                  >>>1297000
            ";;& 
         setLastModified|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "         
               setLastModified
                  Sets the last-modified time of the file or directory named by this abstract pathname.
                  All platforms support file-modification times to the nearest second, but some provide 
                  more precision. The argument will be truncated to fit the supported precision. If the 
                  operation succeeds and no intervening operations on the file take place, then the next 
                  invocation of the lastModified() method will return the (possibly truncated) time 
                  argument that was passed to this method.
               Parameters:
                  time - The new last-modified time, measured in milliseconds since the 
                  epoch (00:00:00 GMT, January 1, 1970)
               Returns:
                  true if and only if the operation succeeded; false otherwise
               Throws:
                  IllegalArgumentException - if the parameter cannot be treated as a number
                                           - if number of arguments != 3
                  NotInPathException - if GNU date is not in path
                                     - if touch is not in path
               Example:
                  File a /tmp/abc
                  a.setLastModified 1297632
                  >>>true
                  a.lastModified
                  >>>1297000
            ";;& 
         delete|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "         
               delete
                  Deletes the file or directory denoted by this abstract pathname. If this pathname 
                  denotes a directory, then the directory must be empty in order to be deleted.
               Parameters:
                  None
               Returns:
                  true if and only if the file or directory is successfully deleted; false otherwise
               Throws:
                  NotInPathException - if rm is not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.delete
                  >>>true
            ";;& 
         isAbsolute|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "         
               isAbsolute
                  Tests whether this abstract pathname is absolute. The definition of absolute 
                  pathname is system dependent. On UNIX systems, a pathname is absolute if its prefix is "/".
               Parameters:
                  None
               Returns:
                  true if this abstract pathname is absolute, false otherwise
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.isAbsolute
                  >>>true
            ";;& 
         getAbsolutePath|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "         
               getAbsolutePath            
                  Returns the absolute pathname string of this abstract pathname.
                  If this abstract pathname is already absolute, then the pathname string is simply 
                  returned as if by the getPath() method. If this abstract pathname is the empty 
                  abstract pathname then the pathname string of the current user directory is returned. 
                  Otherwise this pathname is resolved in a system-dependent way. On UNIX systems, a 
                  relative pathname is made absolute by resolving it against the current user directory.
               Parameters:
                  None
               Returns:
                  The absolute pathname string denoting the same file or directory as this abstract pathname
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.getAbsolutePath
                  >>>/tmp/abc
            ";;& 
         getPath|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "          
               getPath
                  Converts this abstract pathname into a pathname string. 
               Parameters:
                  None
               Returns:
                  The string form of this abstract pathname
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.getPath
                  >>>/tmp/abc
            ";;& 
         createNewFile|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "          
               createNewFile  
                  Creates a new, empty file named by this abstract pathname if and only if a file with 
                  this name does not yet exist. 
               Parameters:
                  None
               Returns:
                  true if the named file does not exist and was successfully created; false if the 
                  named file already exists
               Throws:
                  NotInPathException - if touch is not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.createNewFile
                  >>>true
            ";;& 
         File.createTempFile|createTempFile|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "   
               createTempFile
                  Creates an empty file in the default temporary-file directory, using the given prefix 
                  and suffix to generate its name. Invoking this method is equivalent to invoking 
                  createTempFile.

                  The createTemporaryFile method provides an alternative method to create an empty file 
                  in the temporary-file directory. Files created by that method may have more restrictive 
                  access permissions to files created by this method and so may be more suited to 
                  security-sensitive applications.
               Parameters:
                  prefix - The prefix string to be used in generating the file's name; must be at least 
                  three characters long
                  suffix - The suffix string to be used in generating the file's name is optional. If 
                  missing the suffix ".tmp" will be used
               Returns:
                  An abstract pathname denoting a newly-created empty file
               Throws:
                  IllegalArgumentException - If the prefix argument contains fewer than three characters
                                             if number of arguments !=1 AND !=2
                  IOException - if file could not be created 
                  NotInPathException - if mktemp is not in path
                                     - if chmod is not in path
               Example:
                  File.createTempFile fff
                  >>>/tmp/fff1K1S1FQmOsSF4XC8RD.tmp
                  File.createTempFile fff xxx
                  >>>/tmp/fffREtAnRWdPUCAsFR0msxxx
            ";;&    
         File.createTemporaryFile|createTemporaryFile|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "   
               createTemporaryFile
                  Creates an empty file in the default temporary-file directory, using the given prefix and 
                  suffix to generate its name.

                  The attrs parameter is an optional primitive string of attributes to set when creating 
                  the file. 

                  When using the attrs parameter the resulting file may have more restrictive access 
                  permissions than files created by the createTempFile method.
                  The attrs parameter is a String representing the permissions. It has 9 characters that 
                  are interpreted as three sets of three. The first set refers to the owner's permissions; 
                  the next to the group permissions and the last to others. Within each set, the first 
                  character is 'r' to indicate permission to read, the second character is 'w' to indicate 
                  permission to write, and the third character is 'x' for execute permission. Where a 
                  permission is not set then the corresponding character is set to '-'. 

               Parameters:
                  prefix - The prefix string to be used in generating the file's name; must be at least three characters long
                  suffix - The suffix string to be used in generating the file's name
                  attrs - An optional list of file attributes to set when creating the file
               Returns:
                  An abstract pathname denoting a newly-created empty file
               Throws:
                  IllegalArgumentException - If the prefix argument contains fewer than three characters
                                           - if number of arguments !=2 AND !=3
                  IOException - if file could not be created 
                  NotInPathException - if mktemp is not in path
                                     - if chmod is not in path
               Example:
                  File.createTemporaryFile xxx .tmp rwxrwxrwx
                  >>>/tmp/xxxStlt01lvAKe1P3se8i.tmp
                  ll /tmp/xxxStlt01lvAKe1P3se8i.tmp
                  >>>-rwxrwxrwx 1 $USER $USER 0 14. Feb 22:22 /tmp/xxxStlt01lvAKe1P3se8i.tmp
                  TMPDIR=/
                  File.createTemporaryFile xxx .tmp
                  >>>IOException: file could not be created
            ";;&         
         getName|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getName
                  This is just the last name in the pathname's name sequence.
               Parameters:
                  None
               Returns:
                  The name of the file or directory denoted by this abstract 
                  pathname. This is just the last name in the pathname's name 
                  sequence. If the pathname's name sequence is empty, then the 
                  empty string is returned.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  File a /tmp/abc
                  a.getName
                  >>>abc
               ";;&
         *)   if [[ $match == $(Boolean.FALSE) ]]
              then
                 System.${printStream}.println "                                  
                       No help found for $1
                    "   
              fi
              ;;&
      esac       
      shift
   done         
}
