#############################################################
# Author:  franka
# Date:    2012-04-11
# License: The MIT License
# Copyright (c) <2012> <franka>
#############################################################


#########################
# constructor  function #
#########################

Process() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      # TODO: Check if PID exists
      declare -i pid="$2"

      if ! __visible "$this"; then
         I18n.err.message "Sorry, objectname '\$this' is not valid"
         return 1
      fi  

      if ! __checkForKeywords "$this"; then
         I18n.err.message "Sorry, objectname '\$this' is a keyword"
         return 1
      fi 

      if ! __periodCheck "$this"; then
         I18n.err.message "Sorry, no full stop character allowed in objectname"
         return 1
      fi

      local pointer="$(__getPointer)"

      local class=$FUNCNAME

      __destructor "$this"

      __alias "$this" "$FUNCNAME"
      
      __attribute pid "$pid"

      return $returnValue
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   returnValue=$?
   __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
   return $returnValue
}
__registerClass Process

######################
# getter function(s) #
######################

__getPid() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local class="$2"
   if (( $# == 2 )); then
      local this="$1"
      local key
      for key in "${!__OBJECTPOOL__[@]}"
      do 
         if [[ "$this" == "$key" ]]; then
            local str="${__OBJECTPOOL__["$this"]}"
            declare -i i=0
            for ((i=0; i < ${#str}; i++))
            do
               local char="${str:i:1}"
               if [[ $char == "@" ]]; then
                  local j=$(($i+1))
                  local pointer="${str:j}"
               fi
            done              
         fi
      done
      System.out.println "${__ATTRIBUTEPOOL__[${pointer}@pid]}" 
      return $returnValue
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "${class}" "${FUNCNAME:2}"
   return $returnValue
}

__getParentPid() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local file="$("$this".toString)"
      if command -v ps >/dev/null 2>&1; then
         declare -i pid="$("$this".getPid)"
         declare -i parentPid
         parentPid="$(ps  p "$pid" o ppid --no-headers 2>/dev/null)"
         # TODO: lstrip ! + ""
         System.out.println $parentPid
         return $returnValue
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__getUser() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local file="$("$this".toString)"
      if command -v ps >/dev/null 2>&1; then
         declare -i pid="$("$this".getPid)"
         local owner
         owner="$(ps  p "$pid" o user --no-headers 2>/dev/null)"
         System.out.println "$owner"
         return $returnValue
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__getStatus() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local file="$("$this".toString)"
      if command -v ps >/dev/null 2>&1; then
         declare -i pid="$("$this".getPid)"
         local stat
         stat="$(ps  p "$pid" o stat --no-headers 2>/dev/null)"
         case ${stat:0:1} in
            D)stat="Uninterruptible";;
            R)stat="Running";;
            S)stat="Interruptible";;
            T)stat="Stopped";;
            W)stat="Paging";;
            X)stat="Dead";;
            Z)stat="Defunct";;
            *)stat="Unknown";;
         esac
         System.out.println "$stat"
         return $returnValue
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

##################
#                #
#     STATICS    # 
#                #
##################

Process.create() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      # TODO: Check if PID exists
      local processCommand="$2"
      #set +bm
      $processCommand 1>/dev/null 2>&1 &
      declare -i processPid=$!
      Process "$this" "$processPid"
      return $returnValue
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   returnValue=$?
   __stackOrHelp "Process" "${FUNCNAME}"
   return $returnValue
}
__registerFunction Process.create

complete -W  "$(echo ${__Process__[@]}) all Process" Process.help

#################
# help function #
#################
Process.help() {  
   local printStream=${printStream:-out}  
   if (( $# == 0 )); then
      System.${printStream}.println "
                    Usage: Process.help all|methodname
                    Available methods:
                    -getClass
                    -toString
                    -equals
                    -hashCode
                    -getPid
                    Constructor: 
                    -Process
      " 
      return 0
   fi
   while (($#))
   do
      local match=$(Boolean.FALSE)
      case $1 in
         Process|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               Process
                  Constructor for the Process objects.
               Parameters:
                  objectname
                  <pid>
                  No "." or space character is allowed in the objectname string.
               Returns:
                  None
               Throws:
                  IllegalArgumentException - if number of arguments != 2
               Example:
                  Process a <pid> 
            ";;& 
         getPid|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getPid
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getProcessPid
                  >>>1
            ";;& 
         getClass|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getClass
                  Returns the runtime class of this Object.
               Parameters:
                  None
               Returns:
                  The Class object that represents the runtime class of this object.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getClass
                  >>>class Process
            ";;&
         toString|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               toString
                  Returns a String object representing this Process object in sorted order. 
               Parameters:
                  None
               Throws:
                  NotInPathException - if sort not in path
                                     - if tr not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.toString
                  >>>1
            ";;&
         hashCode|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               hashCode
                  Returns a hash code for this Process object.
               Parameters:
                  None
               Returns:
                  a hash code for this Process.
               Throws:
                  NotInPathException - if bc not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.hashCode
            ";;&
         equals|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               equals
                  Returns true if and only if the argument is a Process object that 
                  represents the same Process value as this object. 
               Parameters:
                  anObject - The object to compare this Process against
               Returns:
                  true if the Process objects represent the same value; false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 1
                                           - if arguent is no object
               Example:
                  Process b 1
                  Process c 1
                  b.equals c
                  >>>true
            ";;&
         *)   if [[ $match == $(Boolean.FALSE) ]]; then
                 System.${printStream}.println "                                  
                       No help found for $1
                    "   
              fi
              ;;& 
      esac               
      shift
   done 
}


