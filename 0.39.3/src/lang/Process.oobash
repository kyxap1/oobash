#############################################################
# Author:  franka
# Date:    2012-04-11
# License: The MIT License
# Copyright (c) <2012> <franka>
#############################################################

# TODO: if there is no tail, try string manipulation ?
# TODO: if there is no tail and no ps and os = linux use /proc where possible
# TODO: get UserId GroupId
# TODO: ProcessNotRunningException OR ProcessException

#########################
# constructor  function #
#########################

Process() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"

      # catch eg "+" param
      (declare -i pid="$2") 2>/dev/null
      if (( $? != 0 )); then
         __throw "IllegalArgumentException" ": Illegal argument: \"$2\""
         returnValue=$?
         __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
         return $returnValue
      fi
      declare -i pid="$2"
      
      if ! __visible "$this"; then
         __throw "IllegalArgumentException" ": Objectname '$this' is not valid"
         returnValue=$?
         __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
         return $returnValue
      fi

      if ! __checkForKeywords "$this"; then
         __throw "IllegalArgumentException" ": Objectname '$this' is a keyword"
         returnValue=$?
         __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
         return $returnValue
      fi 

      if ! __periodCheck "$this"; then
         __throw "IllegalArgumentException" ": No full stop character allowed in objectname"
         returnValue=$?
         __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
         return $returnValue
      fi

      # try to validate pid
      if [[ "$(uname -s 2>/dev/null)" == "Linux" ]]; then
         declare -i maxpid
         maxpid=$(</proc/sys/kernel/pid_max)
         if (( ${pid} < 1 || ${pid} > ${maxpid} )); then
            __throw "IllegalArgumentException" ": Pid \"$pid\" is not valid"
            returnValue=$?
            __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
            return $returnValue
         fi
         if [[ ! -d /proc/${pid} ]]; then
            __throw "NotRunningException" ": Process with pid: \"$pid\" is not running"
            returnValue=$?
            __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
            return $returnValue
         fi
      else
         if command -v ps >/dev/null 2>&1; then
            ps  -p "${pId}" -o stat 2>/dev/null 1>&2
            if (( $? != 0 ));then
               __throw "NotRunningException" ": Process with pid: \"$pid\" is not running"
               returnValue=$?
               __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
               return $returnValue
            fi
         fi
      fi

      local pointer="$(__getPointer)"

      local class="${FUNCNAME}"

      __destructor "${this}"

      __alias "$this" "${FUNCNAME}"
      
      __attribute pid "${pid}"

      return $returnValue
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   returnValue=$?
   __stackOrHelp "${FUNCNAME}" "${FUNCNAME}"
   return $returnValue
}
__registerClass Process

###########
# Methods #
###########

__getPid() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local class="$2"
   if (( $# == 2 )); then
      local this="$1"
      local key
      for key in "${!__OBJECTPOOL__[@]}"
      do 
         if [[ "$this" == "$key" ]]; then
            local str="${__OBJECTPOOL__["$this"]}"
            declare -i i=0
            for ((i=0; i < ${#str}; i++))
            do
               local char="${str:i:1}"
               if [[ ${char} == "@" ]]; then
                  local j=$(($i+1))
                  local pointer="${str:j}"
               fi
            done              
         fi
      done
      if command -v ps >/dev/null 2>&1; then
         if command -v tail >/dev/null 2>&1; then
            local pId
            pId="$(ps  -p "${__ATTRIBUTEPOOL__[${pointer}@pid]}" -o pid 2>/dev/null | tail -1;echo ${PIPESTATUS[@]})"
            if [[ "${pId: -3}" != "0 0" ]]; then
               echo 1
               __throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi
            pId=${pId%????}
            System.out.println ${pId}
            return $returnValue
         else
            __throw "NotInPathException" ": tail not in path"
            returnValue=$?
            __stackOrHelp "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "${class}" "${FUNCNAME:2}"
   return $returnValue
}

__getParentPid() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if command -v ps >/dev/null 2>&1; then
         if command -v tail >/dev/null 2>&1; then
            declare -i pId
            pId="$("$this".getPid)"
            returnValue=$?
            if (( $returnValue != 0 )); then
               return $returnValue
            fi
            local ppid
            ppid="$(ps  -p "${pId}" -o ppid 2>/dev/null | tail -1;echo ${PIPESTATUS[@]})"
            if [[ "${ppid: -3}" != "0 0" ]]; then
               __throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi
            declare -i parentPid=${Ppid%????}
            System.out.println "${parentPid}"
            return $returnValue
         else
            __throw "NotInPathException" ": tail not in path"
            returnValue=$?
            __stackOrHelp "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__getUser() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if command -v ps >/dev/null 2>&1; then
         if command -v tail >/dev/null 2>&1; then
            declare -i pId
            pId="$("$this".getPid)"
            returnValue=$?
            if (( $returnValue != 0 )); then
               return $returnValue
            fi
            local owner
            owner="$(ps  -p "${pId}" -o user 2>/dev/null | tail -1;echo ${PIPESTATUS[@]})"
            if [[ "${owner: -3}" != "0 0" ]]; then
               __throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi
            System.out.println "${owner%????}"
         else
            __throw "NotInPathException" ": tail not in path"
            returnValue=$?
            __stackOrHelp "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"        
      fi
      return $returnValue
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__getCommand() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if command -v ps >/dev/null 2>&1; then
         if command -v tail >/dev/null 2>&1; then
            declare -i pId
            pId="$("$this".getPid)"
            returnValue=$?
            if (( $returnValue != 0 )); then
               return $returnValue
            fi
            local cmd
            cmd="$(ps  -p "${pId}" -o cmd 2>/dev/null | tail -1;echo ${PIPESTATUS[@]})"
            if [[ "${cmd: -3}" != "0 0" ]]; then
               __throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi
            System.out.println "${cmd%????}"
         else
            __throw "NotInPathException" ": tail not in path"
            returnValue=$?
            __stackOrHelp "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"      
      fi
      return $returnValue
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__getStatus() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if command -v ps >/dev/null 2>&1; then
         if command -v tail >/dev/null 2>&1; then
            declare -i pId
            pId="$("$this".getPid)"
            returnValue=$?
            if (( $returnValue != 0 )); then
               return $returnValue
            fi
            local stat
            stat="$(ps -p "$pId" -o s 2>/dev/null | tail -1;echo ${PIPESTATUS[@]})"
            if [[ "${stat: -3}" != "0 0" ]]; then
               __throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi
            # TODO: Decision for states...
            case "${stat%????}" in
               D)stat="Uninterruptible";;
               # R ok
               R)stat="Runnable";;
               # S ok
               S)stat="Sleeping";;
               # T ok
               T)stat="Stopped";;
               # W not valid since the 2.6.xx kernel
               W)stat="Paging";;
               # Z zombie
               Z)stat="Defunct";;
               # only SunOS (letter O)
               O)stat="Running";;
               # only HP-UX
               X)stat="Growing";;
               *)__throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
                 returnValue=$?
                 __stackOrHelp "$2" "${FUNCNAME:2}"
                 return $returnValue;;
               # OS X ps man page:
               #               I       Marks a process that is idle (sleeping for longer than about 20 seconds).
               #               R       Marks a runnable process.
               #               S       Marks a process that is sleeping for less than about 20 seconds.
               #               T       Marks a stopped process.
               #               U       Marks a process in uninterruptible wait.
               #               Z       Marks a dead process (a ``zombie'').
               # uname -s Darwin

               # Gnu Linux ps man page:
               #               D       Uninterruptible sleep (usually IO)
               #               R       Running or runnable (on run queue)
               #               S       Interruptible sleep (waiting for an event to complete)
               #               T       Stopped, either by a job control signal or because it is being traced.
               #               W       paging (not valid since the 2.6.xx kernel)
               #               X       dead (should never be seen)
               #               Z       Defunct ("zombie") process, terminated but not reaped by its parent.
               # uname -s Linux

               # HP-UX ps man page:
               #               0 non-existent; (Null)
               #               S sleeping;
               #               W waiting;
               #               R running;
               #               I intermediate;
               #               Z terminated;
               #               T stopped;
               #               X growing.

               # Sun ps man page:
               #              O Process is running on a processor. (letter O)
               #              S Sleeping: process is waiting for an event to complete.
               #              R Runnable: process is on run queue.
               #              Z Zombie state: process terminated and parent not waiting.
               #              T Process is stopped, either by a job control signal or because it is being traced.

            esac
            System.out.println "${stat}"
            return $returnValue
         else
            __throw "NotInPathException" ": tail not in path"
            returnValue=$?
            __stackOrHelp "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}


__getPriority() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      if command -v ps >/dev/null 2>&1; then
         if command -v tail >/dev/null 2>&1; then
            declare -i pId
            pId="$("$this".getPid)"
            returnValue=$?
            if (( $returnValue != 0 )); then
               return $returnValue
            fi
            declare -i prio
            prio="$(ps  -p "${pId}" -o ni 2>/dev/null | tail -1;echo ${PIPESTATUS[@]})"
            if [[ "${prio: -3}" != "0 0" ]]; then
               __throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi
            declare -i priority=${prio%????}
            System.out.println "${priority}"
            return $returnValue
         else
            __throw "NotInPathException" ": tail not in path"
            returnValue=$?
            __stackOrHelp "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__setPriority() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )); then
      if command -v renice >/dev/null 2>&1; then
         local this="$1"
         declare -i pId
         pId="$("$this".getPid)"
         returnValue=$?
         if (( $returnValue != 0 )); then
            return $returnValue
         fi
         local priority="$3"       
         renice "${priority}" -p "${pId}" 1>/dev/null 2>&1
         if (( $? == 0 )); then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
         return $returnValue
      else
         __throw "NotInPathException" ": renice not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__isDaemon() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      if command -v ps >/dev/null 2>&1; then
         if command -v tail >/dev/null 2>&1; then
            local this="$1"
            declare -i pId
            pId="$("$this".getPid)"
            returnValue=$?
            if (( $returnValue != 0 )); then
               return $returnValue
            fi
            local tty
            tty="$(ps  -p "${pId}" -o tty 2>/dev/null | tail -1;echo ${PIPESTATUS[@]})"
            if [[ "${tty: -3}" != "0 0" ]]; then
               __throw "ProcessException" ": Process with pid: \"$pId\" can't be managed"
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi
            if [[ "${tty%????}" == "?" ]]; then
               Boolean.TRUE
            else
               Boolean.FALSE
            fi
            return $returnValue
         else
            __throw "NotInPathException" ": tail not in path"
            returnValue=$?
            __stackOrHelp "$2" "${FUNCNAME:2}"
            return $returnValue
         fi
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

__kill() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 3 )) || (( $# == 2 )) ; then
      if command -v kill >/dev/null 2>&1; then
         local this="$1"
         declare -i pId
         pId="$("$this".getPid)"
         returnValue=$?
         if (( $returnValue != 0 )); then
            return $returnValue
         fi
         local signal
         if (( $# == 3 )); then
            local signalValid="$(Boolean.FALSE)"
            local key
            declare -u signal="$3"
            for key in "${!__Signals__[@]}"
            do 
               if [[ "$signal" == "${__Signals__[key]}" ]]; then
                  signalValid=$(Boolean.TRUE)  
                  break
               fi
            done
            if [[ "$signalValid" != "$(Boolean.TRUE)" ]]; then
               __throw "IllegalArgumentException" ": Illegal argument: \"$3\""
               returnValue=$?
               __stackOrHelp "$2" "${FUNCNAME:2}"
               return $returnValue
            fi               
         else
            signal="TERM"
         fi       
         kill -s "{$signal}" "${pId}" 1>/dev/null 2>&1
         if (( $? == 0 )); then
            Boolean.TRUE
         else
            Boolean.FALSE
         fi
         return $returnValue
      else
         __throw "NotInPathException" ": kill not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME:2}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $(($#-2))"
   returnValue=$?
   __stackOrHelp "$2" "${FUNCNAME:2}"
   return $returnValue
}

##################
#                #
#     STATICS    # 
#                #
##################

Process.create() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 2 )); then
      local this="$1"
      local processCommand="$2"
      if command -v  $processCommand >/dev/null 2>&1; then
         declare -i processPid
         processPid=$(
         $processCommand 2>/dev/null 1>&2 &
         System.out.println $!
         )
         Process "$this" "${processPid}" 2>/dev/null
         returnValue=$?
         if (( $returnValue == 0 )); then
            Boolean.TRUE
            return $returnValue
         fi
         Boolean.FALSE
         return $returnValue
      else
         __throw "NotInPathException" ": ${processCommand} not in path"
         returnValue=$?
         __stackOrHelp "Process" "${FUNCNAME}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   returnValue=$?
   __stackOrHelp "Process" "${FUNCNAME}"
   return $returnValue
}
__registerFunction Process.create

Process.exists() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   if (( $# == 1 )); then
      declare -i pId="$1"
      if command -v ps >/dev/null 2>&1; then
         ps  -p "${pId}" -o stat 2>/dev/null 1>&2
         if (( $? == 0 ));then
            Boolean.TRUE
            return $returnvalue
         fi
         Boolean.FALSE
         return $returnvalue
      else
         __throw "NotInPathException" ": ps not in path"
         returnValue=$?
         __stackOrHelp "$2" "${FUNCNAME}"
         return $returnValue
      fi
   fi
   __throw "IllegalArgumentException" ": Wrong number of arguments $#"
   returnValue=$?
   __stackOrHelp "Process" "${FUNCNAME}"
   return $returnValue
}
__registerFunction Process.find

complete -W  "$(echo ${__Process__[@]}) all Process" Process.help

#################
# help function #
#################
Process.help() {  
   local printStream=${printStream:-out}  
   if (( $# == 0 )); then
      System.${printStream}.println "
                    Usage: Process.help all|methodname
                    Available methods:
                    -getClass -toString -equals -hashCode 
                    -getUser -getStatus -getCommand -getPid
                    -getPriority -setPriority -kill -isDaemon
                    -Process.create -Process.exists
                    Constructor: 
                    -Process
      " 
      return 0
   fi
   while (($#))
   do
      local match=$(Boolean.FALSE)
      case $1 in
         Process|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               Process
                  Constructor for the Process objects.
               Parameters:
                  objectname
                  <pid>
                  No "." or space character is allowed in the objectname string.
               Returns:
                  None
               Throws:
                  IllegalArgumentException - if number of arguments != 2
                                           - if objectname is not valid
                                           - if objectname is a keyword
                                           - if objectname contains full stop character
               Example:
                  Process a <pid> 
            ";;& 
         getParentPid|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getParentPid
                  Returns the value of parent pid
               Parameters:
                  None
               Returns:
                  The value of parent pid or 0, if there is no parent pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process initProc 1
                  initProc.getParentPid
                  >>>0
            ";;& 
         getUser|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getUser
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getUser
                  >>>1
            ";;& 
         getStatus|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getStatus
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getStatus
                  >>>1
            ";;& 
         getCommand|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getCommand
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getCommand
                  >>>1
            ";;& 
         getPriority|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getPriority
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getPriority
                  >>>1
            ";;& 
         setPriority|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               setPriority
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.setPriority
                  >>>1
            ";;& 
         kill|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               kill
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.kill
                  >>>1
            ";;& 
         isDaemon|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               isDaemon
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.isDaemon
                  >>>1
            ";;& 
         Process.create|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               Process.create
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process.create
                  >>>1
            ";;& 
         Process.exists|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               Process.exists
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process.exists
                  >>>1
            ";;& 
         getPid|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getPid
                  Returns the value of pid
               Parameters:
                  None
               Returns:
                  The value of pid.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getPid
                  >>>1
            ";;& 
         getClass|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               getClass
                  Returns the runtime class of this Object.
               Parameters:
                  None
               Returns:
                  The Class object that represents the runtime class of this object.
               Throws:
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.getClass
                  >>>class Process
            ";;&
         toString|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               toString
                  Returns a String object representing this Process object in sorted order. 
               Parameters:
                  None
               Throws:
                  NotInPathException - if sort not in path
                                     - if tr not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.toString
                  >>>1
            ";;&
         hashCode|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               hashCode
                  Returns a hash code for this Process object.
               Parameters:
                  None
               Returns:
                  a hash code for this Process.
               Throws:
                  NotInPathException - if bc not in path
                  IllegalArgumentException - if number of arguments != 0
               Example:
                  Process b 1
                  b.hashCode
            ";;&
         equals|all)
            match=$(Boolean.TRUE)
            System.${printStream}.println "
               equals
                  Returns true if and only if the argument is a Process object that 
                  represents the same Process value as this object. 
               Parameters:
                  anObject - The object to compare this Process against
               Returns:
                  true if the Process objects represent the same value; false otherwise.
               Throws:
                  IllegalArgumentException - if number of arguments != 1
                                           - if arguent is no object
               Example:
                  Process b 1
                  Process c 1
                  b.equals c
                  >>>true
            ";;&
         *)   if [[ "${match}" == "$(Boolean.FALSE)" ]]; then
                 System.${printStream}.println "                                  
                       No help found for $1
                    "   
              fi
              ;;& 
      esac               
      shift
   done 
}


