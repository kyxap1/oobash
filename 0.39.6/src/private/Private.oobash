##################################################################
# Author:  andreas.gregor.frank@googlemail.com                                
#     
# License: The MIT License
#
# Copyright (c) <2010> <andreas.gregor.frank@googlemail.com>

#######################
#######################
##                   ##
##      PRIVATE      ## 
##                   ##
#######################
#######################

# Index of content:
# __lookForLoggingPropertiesFile() check for log4oobash.properties file in the same directory from where this file gets sourced
# __checkForKeywords() checks if objectname argument for a constructor is a keyword
# __periodCheck() check if given string contains "." character
# __throw() throws an exception with name of exception and message
# __attribute() stores an attribute of an object
# __destructor() destroys a given object
# __unalias() deletes all bash aliases for an object (object.method=object.method)
# __alias() creates all bash aliases for an object (object.method=object.method)
# __visible() check if given string is visible
# __strUpper() returns given string uppercase
# __strLower() returns given string lowercase
# __mathConverter() validates and converts input for valid input for the math methods
# __posixFilePermissionsConverter() converts a "rwxrwxrwx" file permission string to octal
# __i18nMessage() translates and prints message to given channel
# __cleanUpObjectsPool() destroys all objects
# __cleanUpFunctions() unsets all functions
# __cleanUpClasses() unsets all class constructors, class arrays, class help functions, class methods
# __cleanUpVars() unsets the registered variables
# __dependencyCheck() check for external commands (element of __Dependencies__ array) that are used in this framework
# __gnudateCheck() check for gnu date
# __gnustatCheck() checks for gnu stat
# __stackOrHelp() decision: call stacktrace or help
# __tracebackHeader() prints the traceback header to stderr
# __getPointer() creates an object pointer (unique identifier)
# __stacktrace() generates stacktrace
# __isArray() checks if given parameter is an array
# __isAssocArray() checks if given parameter is an associative array
# __isWriteable() checks if given parameter is writeable
# __stripPath() strips double and trailing "/" characters in given path



# private
# check for log4oobash.properties file in the same directory
# from where this file gets sourced
# called by:
# every time you source this framework
__lookForLoggingPropertiesFile() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local call="$1"
   local directory=$(__dirname ${call/[0-9]* /} 2>/dev/null)
   if [[ -r "${directory}"/"${__LOGGINGPROPERTIESFILE__}" ]]; then
      __LOGGERPROPS__=$(Boolean.TRUE)
   else
      __LOGGERPROPS__=$(Boolean.FALSE)
   fi
   return 0
}
__registerFunction __lookForLoggingPropertiesFile
__registerVar __LOGGERPROPS__

# private
# checks if objectname argument 
# for a constructor is a keyword
# called by:
# -every constructor
__checkForKeywords() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local word="$1"
   local keyword
   for keyword in ${__Keywords__[@]}
   do 
      if [[ "${word}" == "${keyword}" ]]; then
         return 1
      fi
   done
   return 0
}
__registerFunction __checkForKeywords
__registerVar __Keywords__

# private
# check if given string contains "." character 
# called by:
# -every constructor
__periodCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   str="$1"
   declare -i i
   for ((i=0; i < ${#str}; i++))
   do
      local char="${this:i:1}"
      case "${char}" in
         .) return 1;;
      esac
   done
   return 0
}
__registerFunction __periodCheck

# private
# throws an exception with name of exception and message
# called by:
# every public method
# and __dependencyCheck
__throw() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   local exception="$1"
   local message="$2"
   __tracebackHeader
   System.err.println "${exception}${message}"
   if [[ ! -z "${__ExceptionValues__[$exception]}" ]]; then
      returnValue=${__ExceptionValues__[$exception]}
   else   
      returnValue=${__ExceptionValues__[Unknown]}
   fi
   return $returnValue
}
__registerFunction __throw

# private  
# stores an attribute of an object
# called by:
# -every constructor
__attribute() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local key="$1"
   local value="$2"
   __OBJECTPOOL__["${this}"]=$class@$pointer
   __ATTRIBUTEPOOL__["${pointer}"@"${key}"]="$value"
   return 0
}
__registerFunction __attribute

# private  
# destroys a given object
# called by:
# -every constructor
__destructor() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local this="$1"
   local string="${__OBJECTPOOL__["${this}"]}"
   if [[ ! -z "${string}" ]]; then
      declare -i i=0
      for ((i=0; i < ${#string}; i++))
      do
         local char="${string:i:1}"
         if [[ ${char} == "@" ]]; then
            local i=$(($i+1))
            local pointer="${string:i}"
            local lastClass="${string:0:(i-1)}"
            break
         fi
      done
      unset __OBJECTPOOL__["${this}"]
      
      local key
      for key in "${!__ATTRIBUTEPOOL__[@]}"
      do
         if [[ "${key}" == "${pointer}"* ]]; then
            unset __ATTRIBUTEPOOL__["${key}"]
         fi      
      done
      
      __unalias "$this" "$lastClass"
   fi
   return 0
}
__registerFunction __destructor

# private
# deletes all bash aliases for an object
# (object.method=object.method).
# Only active in interactive bash
# called by:
# -every constructor
if [[ ! -z "$PS1" ]]; then
   __unalias() {
      __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
      local this="$1"
      local lastClass="$2"
      local method
      for method in $(eval echo \${__${lastClass}__[@]})
      do
         unalias "${this}"."${method}" 2>/dev/null
      done 
   }
else
   __unalias() {
      :
      return 0
   }
fi
__registerFunction __unalias

# private
# creates all bash aliases for an object
# (object.method=object.method).
# Only active in interactive bash
# The alias does not avoid the 
# "command not found"-situation,
# but you can enjoy autocompletion
# in the interactive bash. 
# called by:
# -every constructor
if [[ ! -z "$PS1" ]]; then
   __alias() {
      __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
      local this="$1"
      local class="$2"
      local method
      for method in $(eval echo \${__${class}__[@]})
      do
         BASH_ALIASES["${this}"."${method}"]=""${this}"."${method}""
      done
      return 0
   }   
else
   __alias() {
      :
      return 0
   }
fi
__registerFunction __alias

# private
# check if given string is visible 
# called by:
# -every constructor
# -isVisible (String method)
__visible() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local str="$1"
   local unsetAtEnd="$(Boolean.FALSE)" 
   local bool="$(Boolean.FALSE)" 
   # is extglob set ?
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd="$(Boolean.TRUE)"
   fi 
   if [[ "$str" != "" ]]; then
      if [[ "${str##+([[:graph:]])}" == "" ]]; then
         bool="$(Boolean.TRUE)"
      fi      
   fi       
   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
   if [[  "${bool}" == "$(Boolean.TRUE)" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __visible

# private  
# returns given string uppercase
# called by:
# -__compareToIgnoreCase
# -__toUpperCase
# -__capitalize
# -__title
__strUpper() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -u str="$1"
   local upper=''
   declare -i i=0
   for ((i=0; i < ${#str}; i++))
   do
      local char="${str:i:1}"
      local valueOf=$(printf '%d\n' "'$char")
      case "${valueOf}" in
         # small sharp s 
         223 )                  
         upper="${upper}""ẞ";;
         228|246|252|224|226|230|231|232|233|234|235|238|239|244|156|249|251|261|281|243|263|322|324|347|378|380|225|237|241|250|259|537|351|539|355|283|367|253|269|314|328|341|345|353|382|271|357|248|229|337|369|236|242|240|254)
         upper="${upper}""${char~}";;       
         * ) 
         upper="${upper}""${char}" ;;
      esac
   done
   System.out.println "${upper}"
   return 0   
}
__registerFunction __strUpper

# private
# returns given string lowercase
# called by:
# -__toLowerCase
# -__title
__strLower() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -l str="$1"
   local lower=''
   declare -i i=0
   for ((i=0; i < ${#str}; i++))
   do
      local char="${str:i:1}"
      local valueOf=$(printf '%d\n' "'$char")
      case $valueOf in
         # uppercase sharp s
         7838)
         lower="${lower}""ß";;
         220|196|214|192|194|198|199|200|201|202|203|206|207|212|140|217|219|260|280|211|262|321|323|346|377|379|193|205|209|218|258|536|350|538|354|282|366|221|268|313|327|340|344|352|381|270|356|216|197|336|368|204|210|208|222)
         lower="${lower}""${char~}";; 
         * ) 
         lower="${lower}""${char}" ;;
      esac
   done
   System.out.println "${lower}"
   return 0
}
__registerFunction __strLower

# private
# validates and converts input 
# for valid input for the math methods.
# bc is used in the math methods
# to do the calculations.
# called by:
# -Math.sin
# -Math.cos
# -Math.tan
# -Math.atan
# -Math.asin
# -Math.acos
# -Math.max
# -Math.min
# -Math.abs
# -Math.sqrt
# -Math.exp
# -Math.expm1
# -Math.sinh
# -Math.cosh
# -Math.tanh
# -Math.adder
# -Math.multiplier
# -Math.log
# -Math.log10
# -Math.log1p
# -Math.toDegrees
# -Math.toRadians
# -Math.ceil
# -Math.floor
# -Math.hypot
__mathConverter() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local input="$1"
   if [[ "${input}" == "NaN" ]]; then
      System.out.println "NaN"
      return 0
   elif [[ "${input}" == "Infinity" ]]; then
      System.out.println "Infinity"
      return 0    
   elif [[ "${input}" == "-Infinity" ]]; then
      System.out.println "-Infinity"
      return 0  
   fi 
   local unsetAtEnd=$(Boolean.FALSE) 
   # is extglob set ?
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd=$(Boolean.TRUE)
   fi 
   if [[ "${input}" =~ ^[-]?[0-9]*\.?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -f
      System.out.println "${input/[eE]/ * 10 ^ }"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\.?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -f
      output="${input/[eE]/ * 10 ^ }"
      System.out.println "${output:1}"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]*\,?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -f
      output="${input/[eE]/ * 10 ^ }"
      System.out.println "${output/,/.}"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\,?[0-9]+([eE][-]?[0-9]+)+$ ]]; then
      set -f
      output="${input/[eE]/ * 10 ^ }"
      output="${output:1}"
      System.out.println "${output/,/.}"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]*\.?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -f
      System.out.println "${input/[eE]+/ * 10 ^ }"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\.?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -f
      output="${input/[eE]+/ * 10 ^ }"
      System.out.println "${output:1}"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]*\,?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -f
      output="${input/[eE]+/ * 10 ^ }"
      System.out.println "${output/,/.}"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]*\,?[0-9]+([eE][+]?[0-9]+)+$ ]]; then
      set -f
      output="${input/[eE]+/ * 10 ^ }"
      output="${output:1}"
      System.out.println "${output/,/.}"
      set +f 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?([0-9]*\.[0-9]+|[0-9]+)$ ]]; then
      System.out.println $input
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?([0-9]*\.[0-9]+|[0-9]+)$ ]]; then
      System.out.println "${input:1}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?([0-9]*\,[0-9]+|[0-9]+)$ ]]; then
      System.out.println "${input/,/.}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[+]?([0-9]*\,[0-9]+|[0-9]+)$ ]]; then
      output="${input:1}"
      System.out.println "${output/,/.}" 
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi     
      return 0
   elif [[ "${input}" =~ ^[-]?[0-9]+$ ]]; then
      System.out.println "${input}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi  
      return 0
   elif [[ "${input}" =~ ^[+]?[0-9]+$ ]]; then
      System.out.println "${input:1}"
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi  
      return 0
   fi
   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi  
   # Cannot recognize...
   return 1
}
__registerFunction __mathConverter

# private
# converts a "rwxrwxrwx" file permission
# string to octal (eg 777)
# called by:
# -File.createTemporaryFile
__posixFilePermissionsConverter() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local unsetAtEnd=$(Boolean.FALSE) 
   # is extglob set ?
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd=$(Boolean.TRUE)
   fi 
   local permissions="$1"
   local octal=''
   declare -i octalPerm=0
   if [[ "${permissions}" =~ ^([r-][w-][x-]){3}$ ]]; then
      # convert to octal format
      declare -i i=0
      for ((i=0; i < 9; i++))
      do
         local perm="${permissions:i:1}"
            case ${perm} in
               r)octalPerm=$(($octalPerm+4));;
               w)octalPerm=$(($octalPerm+2));;
               x)octalPerm=$(($octalPerm+1));;
            esac
         # starting with 0
         if (( $i == 2 || $i == 5 || $i== 8 )); then
            octal=${octal}${octalPerm}
            octalPerm=0  
         fi        
      done
   else
      if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
         shopt -u extglob
      fi
      return 1
   fi
   if [[ "${unsetAtEnd}" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
   System.out.println "${octal}"   
   return 0
}
__registerFunction __posixFilePermissionsConverter

# private
# translates and prints message to given channel
# called by:
# -I18n.err.print -I18n.out.print -I18n.err.println -I18n.out.println
__i18nMessage() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local message="$1"
   # msgid "" can be mapped to meta informations 
   if [[ "${message}" == "" ]]; then
       System.${printStream}.${print} ""
       return 0
   fi
   if command -v eval_gettext >/dev/null 2>&1; then
      System.${printStream}.${print} "$(eval_gettext "$message")"
      return 0
   else
      # fall back to old school bash i18n
      System.${printStream}.${print} "$(eval System.out.println \$"\"${message}\"")"
      return 0
   fi
   return 0
}
__registerFunction __i18nMessage

# private  
# destroys all objects
# does not need registration. unset action in __cleanUp function
# called by:
# __cleanUp
__cleanUpObjectsPool() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local obj
   for obj in ${!__OBJECTPOOL__[@]} 
   do 
      __destructor "${obj}"
   done
   return 0
}

# private  
# unsets all functions
# does not need registration. unset action in __cleanUp function
# called by:
# __cleanUp
__cleanUpFunctions() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local value
   for value in ${!__Registry__[@]}
   do 
      if [[ "${__Registry__[$value]}" == "function" ]]; then
         unset -f "${value}" 
      fi
   done
   return 0
}

# private  
# unsets all class constructors, class arrays, class help functions, class methods
# does not need registration. unset action in __cleanUp function
# called by:
# __cleanUp
__cleanUpClasses() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local value
   for value in ${!__Registry__[@]}
   do 
      if [[ "${__Registry__[$value]}" == "class" ]]; then
         local meth
         for meth in $(eval echo \${__${value}__[@]})
         do 
            unset -f __${meth}
         done
         unset $(eval echo __${value}__  __${value}Methods__)
         unset -f $(eval echo $value ${value}.help)
      fi
   done
   return 0
}

# private  
# unsets the registered variables
# does not need registration. unset action in __cleanUp function
# called by:
# __cleanUp
__cleanUpVars() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local value
   for value in ${!__Registry__[@]}
   do 
      if [[ "${__Registry__[$value]}" == "var" ]]; then
         unset ${value}
      fi
   done   
   return 0
}

# private
# check for external commands that are used in this framework
# Throws:
#    NotInPathException - if element of __Dependencies__ array is not in path
# called by:
# every time you source this framework
__dependencyCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local bool="$(Boolean.TRUE)"
   declare -i i
   for ((i=0; i < ${#__Dependencies__[@]}; i++))
   do
      if ! command -v ${__Dependencies__[i]} >/dev/null 2>&1; then
         bool="$(Boolean.FALSE)"
         __throw "NotInPathException" ": ${__Dependencies__[i]} not in path"
      else
         case "${__Dependencies__[i]}" in
            date) if ! __gnudateCheck; then
                     bool="$(Boolean.FALSE)"
                     __throw "NotInPathException" ": GNU date not in path"
                  fi;;
            stat) if ! __gnustatCheck; then
                     bool="$(Boolean.FALSE)"
                     __throw "NotInPathException" ": GNU stat not in path"
                  fi;;
            readlink) if ! __gnureadlinkCheck; then
                         bool="$(Boolean.FALSE)"
                         __throw "NotInPathException" ": GNU readlink not in path"
                      fi;;                      
         esac
      fi
   done
   if [[ "${bool}" == "$(Boolean.TRUE)" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __dependencyCheck

# private
# check for gnu date
# called by:
# __dependencyCheck
# System.currentTimeMillis
# System.currentTimeNanos
# System.runtime
#__setLastModified
__gnudateCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   # For this framework it is important to work with a gnu date, so:
   # special check for gnu date with nanoseconds gnu feature:
   if command -v date >/dev/null 2>&1; then
      local testtimestamp
      testtimestamp="$(date "+%N" 2>/dev/null)"
      if [[ "${testtimestamp: -1}" == "N" ]]; then
         return 1
      fi
   else
      return 1
   fi
   return 0
}
__registerFunction __gnudateCheck

# private
# check for gnu stat
# called by:
# __dependencyCheck
# __getTotalSpace
# __getUsableSpace
# __getFreeSpace
# __lastModified
__gnustatCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   # For this framework it is important to work with a gnu stat, so:
   # special check for gnu stat with "--file-system" gnu feature:
   if command -v stat >/dev/null 2>&1; then
      stat --file-system / 2>/dev/null 1>&2
      if (( $? != 0 )); then
         return 1
      fi
   else
      return 1
   fi
   return 0
}
__registerFunction __gnustatCheck

# private
# check for gnu readlink
# called by:
# __dependencyCheck
# __getCanonicalPath
__gnureadlinkCheck() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   # For this framework it is important to work with a gnu stat, so:
   # special check for gnu stat with "--file-system" gnu feature:
   if command -v readlink >/dev/null 2>&1; then
      readlink -f / 2>/dev/null 1>&2
      if (( $? != 0 )); then
         return 1
      fi
   else
      return 1
   fi
   return 0
}
__registerFunction __gnureadlinkCheck

# private
# decision: call stacktrace or help
# called by:
# every funtion that throws an exception
__stackOrHelp() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   # interactive --> help
   if [[ ! -z "$PS1" ]]; then
      if [[ $(Boolean.parseBoolean "$__HELP__") == "$(Boolean.TRUE)" ]]; then
         local printStream=err
         local class="$1"
         local func="$2"
         ${class}.help ${func}
      fi
   # not interactive --> stacktrace
   else
      if [[ "$(Boolean.parseBoolean ${__STACKTRACE__})" == "$(Boolean.TRUE)" ]]; then
         __stacktrace
      fi
   fi
   return 0
}
__registerFunction __stackOrHelp

# private
# prints or prints not the traceback header to stderr
# called by:
# __throw
__tracebackHeader() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   if [[ $(Boolean.parseBoolean "$__STACKTRACE__") == "$(Boolean.TRUE)" ]] && [[ -z "$PS1" ]];  then
      System.err.println "Traceback (most recent call first):"
   fi
   return 0
}
__registerFunction __tracebackHeader

# private
# creates an object pointer (unique identifier)
# called by:
# all constructors
__getPointer() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   if __gnudateCheck; then
      # real nanoseconds are not available on every system --> + random
      System.out.println $(System.currentTimeNanos)${RANDOM}${RANDOM}
   else
      if command -v date 2>&1 1>/dev/null; then    
         System.out.println $(date "+%Y%m%d%H%M%S")${RANDOM}${RANDOM}${RANDOM}
      else    
         # not my problem...
         System.out.println ${RANDOM}${RANDOM}${RANDOM}${RANDOM}${RANDOM}${RANDOM} 
      fi
   fi
   return 0
}
__registerFunction __getPointer

# private 
# generates stacktrace
# called by:
# __stackOrHelp
__stacktrace() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   declare -i returnValue=0
   # no __throw and no __stacktrace -> i=2
   declare -i i=2
   until [[ "${FUNCNAME[$i]}" = "main" ]]
   do
      System.err.println "   File \"${BASH_SOURCE[$i+1]}\", line ${BASH_LINENO[$i]}, in ${FUNCNAME[$i]}"
      ((i++))
   done
   declare -i pid=${BASHPID}
   shopt -s extglob
   if [[ "$(uname -s 2>/dev/null)" == "Linux" ]]; then
      declare -i index=0
      declare -a status
      while (( $pid >= 1 ))
      do
         mapfile status </proc/$pid/status
         until [[ ${status[$index]:0:4} == "PPid" ]]
         do
            ((index++))
         done
         command=$(</proc/$pid/cmdline)
         System.err.println "   Process ${command}, pid ${pid}"
         pid=${status[$index]/PPid:/}
      done
   else
      if command -v ps 2>&1 1>/dev/null; then
         if command -v tail 2>&1 1>/dev/null; then
            while (( $pid >= 1 ))
            do
               local process="$(ps -p $pid -o command 2>/dev/null | tail -1 2>/dev/null)"
               local showpid="$(ps -p $pid -o pid 2>/dev/null | tail -1 2>/dev/null)"
               System.out.print "   Process ${process##+([[:space:]])}"
               System.out.println ", pid ${showpid##+([[:space:]])}"               
               pid=$(ps -p "${pid}"  -o ppid 2>/dev/null | tail -1 2>/dev/null)
            done
         fi
      fi
   fi
   shopt -u extglob
   return $returnValue
}
__registerFunction __stacktrace

# private
# checks if given parameter is an array
__isArray() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local tmp="$(declare -p "$1" 2>/dev/null)"
   tmp="${tmp/declare -/}"
   if [[ "${tmp:0:1}" == "a" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __isArray

# private
# checks if given parameter is an associative array
__isAssocArray() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local tmp="$(declare -p "$1" 2>/dev/null)"
   tmp="${tmp/declare -/}"
   if [[ "${tmp:0:1}" == "A" ]]; then
      return 0
   else
      return 1
   fi
}
__registerFunction __isAssocArray

# private
# checks if given parameter is writeable
__isWriteable() {
   __decoratorCheck  "${FUNCNAME[0]}" "${BASH_SOURCE[0]}" "$@"
   local tmp
   tmp="$(declare -p "$1" 2>/dev/null)"
   if (( $? == 0 )); then
      tmp="${tmp/declare -/}"
      declare -i i
      for ((i=0; i < ${#tmp}; i++))
      do
         local char="${tmp:i:1}"
         case "${char}" in
            "r") return 1;;
            " ") return 0;;
         esac
      done
   else
      return 1
   fi
}
__registerFunction __isWriteable

# private
# strips double and trailing "/" characters in given path
# called by:
# __dirname
# __basename
# File constructor
__stripPath() {
   local path="$1"

   # empty --> nothing to do
   if [[ -z "${path}" ]]; then
      System.out.println ""
      return 0
   fi

   # Strip trailing '/' characters from path
   local tmppath=''
   while [[ "${tmppath}" != "${path}" ]]
   do
      tmppath="${path}"
      path="${tmppath%/}"
   done

   # now empty --> only "/" characters --> path is "/"
   if [[ -z "${path}" ]]; then
      System.out.println "/"
      return 0
   fi

   # Strip double '/' characters from path
   tmppath=''
   local lastchar=''
   for ((i=0; i < ${#path}; i++))
   do
      local char="${path:i:1}"
      if [[ "${lastchar}" != "/" ]]; then
         tmppath="${tmppath}""${char}"
      else
         if [[ "${char}" != "${lastchar}" ]]; then
            tmppath="${tmppath}""${char}"
         fi
      fi
      lastchar=${char}
   done
   path="${tmppath}"
   System.out.println "${path}"
   return 0
}
__registerFunction __stripPath

# extglob has to be set, to be able to source __isInteger __isNegInteger __isPosInteger without errors
declare unsetAtEnd
shopt -q extglob
# if extglob not set already --> set it now and change boolean 
if (( $? == 1 )); then
   shopt -s extglob
   unsetAtEnd="true"
fi
# private
# check for integer input
# called by:

__isInteger()
{
   local unsetAtEnd
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd="$(Boolean.TRUE)"
   fi 
   case "$1" in
      ?([+-])+([[:digit:]]) )
         return 0;;
      *) return 1;;
   esac
   if [[ "$(Boolean.parseBoolean "$unsetAtEnd")" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
}
__registerFunction __isInteger

# private
# check for pos. integer input
# called by:

__isPosInteger()
{
   local unsetAtEnd
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd="$(Boolean.TRUE)"
   fi 
   case "$1" in
      ?([+])+([[:digit:]]) )
         return 0;;
      *) return 1;;
   esac
   if [[ "$(Boolean.parseBoolean "$unsetAtEnd")" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
}
__registerFunction __isPosInteger

# private
# check for neg. integer input
# called by:

__isNegInteger()
{
   local unsetAtEnd
   shopt -q extglob
   # if extglob not set already --> set it now and change boolean 
   if (( $? == 1 )); then
      shopt -s extglob
      unsetAtEnd="$(Boolean.TRUE)"
   fi 
   case "$1" in
      ?([-])+([[:digit:]]) )
         return 0;;
      *) return 1;;
   esac
   if [[ "$(Boolean.parseBoolean "$unsetAtEnd")" == "$(Boolean.TRUE)" ]]; then
      shopt -u extglob
   fi
}
__registerFunction __isNegInteger


if [[ "${unsetAtEnd}" == "true" ]]; then
   shopt -u extglob
fi
unset unsetAtEnd